<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Analog Clock + Date (outside angle)</title>
  <style>
    body{
      margin:0;
      min-height:100vh;
      display:grid;
      place-items:center;
      background:#ececec;
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif;
    }
    .wrap{
      display:grid;
      gap:10px;
      justify-items:center;
      padding:18px;
    }
    #mount{
      width:min(92vw, 420px);
      aspect-ratio:1/1;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div id="mount" aria-label="アナログ時計"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.2.4/dist/svg.min.js"></script>

  <script>
    /* ===== テーマ ===== */
    const theme = {
      frame:"#8a4f3a",
      dial:"#f7f7f5",
      text:"#101010",
      dotMinor:"rgba(0,0,0,0.35)",
      dotMajor:"#1a1a1a",
      hour:"#111",
      minute:"#111",
      second:"#9aa0a6",
      dateText:"rgba(0,0,0,0.70)",
      dateSub:"rgba(0,0,0,0.55)",
      sat:"#1f4fd8",
      sun:"#d32f2f"
    };

    const weekJP = ["日","月","火","水","木","金","土"];
    const pad2 = (n) => String(n).padStart(2,"0");

    const draw = SVG()
      .addTo("#mount")
      .viewbox(0,0,400,400)
      .size("100%","100%");

    const cx = 200, cy = 200;

    const polar = (deg, r) => {
      const a = deg * Math.PI / 180;
      return { x: cx + Math.sin(a) * r, y: cy - Math.cos(a) * r };
    };

    const normDeg = d => ((d % 360) + 360) % 360;

    const shortestDelta = (a, b) => {
      let d = normDeg(b) - normDeg(a);
      if (d > 180) d -= 360;
      if (d < -180) d += 360;
      return d;
    };

    /* ===== フレーム ===== */
    draw.circle(400).center(cx,cy).fill(theme.frame);
    draw.circle(392).center(cx,cy).fill("none")
      .stroke({width:4, color:"rgba(255,255,255,.1)"});
    draw.circle(392).center(cx,cy).fill("none")
      .stroke({width:10, color:"rgba(0,0,0,.22)"}).opacity(.35);

    /* ===== 文字盤 ===== */
    const dialR = 172;
    draw.circle(dialR*2).center(cx,cy)
      .fill(theme.dial)
      .stroke({width:1, color:"rgba(0,0,0,.1)"});

    /* ===== 目盛り ===== */
    const ticks = draw.group();
    for(let i=0;i<60;i++){
      const p = polar(i*6, dialR*0.92);
      ticks.circle(i%5===0 ? 5 : 3)
        .center(p.x, p.y)
        .fill(i%5===0 ? theme.dotMajor : theme.dotMinor);
    }

    /* ===== 数字 ===== */
    const nums = draw.group();
    const numberRadius = dialR * 0.74;
    const fontSize = 42;
    const globalDy = -fontSize * 0.05;
    const tightK = 0.27;
    const dx = fontSize * tightK;

    function drawNumber(n, x, y){
      const yy = y + globalDy;
      if(n < 10){
        nums.text(String(n))
          .font({family:"Georgia,'Times New Roman',serif", size:fontSize, weight:700})
          .fill(theme.text)
          .attr({x, y:yy, "text-anchor":"middle", "dominant-baseline":"middle"});
        return;
      }
      const s = String(n);
      nums.text(s[0])
        .font({family:"Georgia,'Times New Roman',serif", size:fontSize, weight:700})
        .fill(theme.text)
        .attr({x:x-dx, y:yy, "text-anchor":"middle", "dominant-baseline":"middle"});
      nums.text(s[1])
        .font({family:"Georgia,'Times New Roman',serif", size:fontSize, weight:700})
        .fill(theme.text)
        .attr({x:x+dx, y:yy, "text-anchor":"middle", "dominant-baseline":"middle"});
    }

    for(let n=1;n<=12;n++){
      const p = polar((n%12)*30, numberRadius);
      drawNumber(n, p.x, p.y);
    }

    /* ===== Flip Date Mini（外角側） ===== */
    function easeInOutCubic(t){
      return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
    }

    class FlipUnit{
      constructor(draw, x, y, w, h, opts={}){
        this.draw=draw; this.x=x; this.y=y; this.w=w; this.h=h;
        this.half=h/2;
        this.value="00";
        this.isFlipping=false;

        this.opticalNudge = opts.opticalNudge ?? 5;

        draw.rect(w,h).move(x+2,y+3)
          .fill("rgba(0,0,0,.25)").radius(6).opacity(.35);

        this.card=draw.group();
        this.card.rect(w,h).move(x,y).fill("#1f1f1f").radius(6);
        this.card.rect(w,this.half).move(x,y).fill("#262626").radius(6);

        const seamY = y + this.half + 0.5;
        this.card.line(x+6,seamY,x+w-6,seamY)
          .stroke({width:1,color:"rgba(255,255,255,.1)"});

        this.clipTop=draw.clip().add(draw.rect(w,this.half).move(x,y));
        this.clipBot=draw.clip().add(draw.rect(w,this.half).move(x,y+this.half));

        this.topStatic=draw.group().clipWith(this.clipTop);
        this.botStatic=draw.group().clipWith(this.clipBot);
        this.flap=draw.group().clipWith(this.clipTop);

        this.font={ family:"ui-monospace, Menlo, Consolas, monospace", size:38, weight:700 };

        this.measure = draw.text("00")
          .font(this.font)
          .fill("none")
          .opacity(0)
          .attr({ x:this.x+this.w/2, y:0, "text-anchor":"middle" });

        this.topText=this._txt(this.topStatic,this.value);
        this.botText=this._txt(this.botStatic,this.value);
        this.flapText=this._txt(this.flap,this.value);

        this._setText(this.topText,this.value);
        this._setText(this.botText,this.value);
        this._setText(this.flapText,this.value);
      }

      _txt(g,str){
        return g.text(str)
          .font(this.font)
          .fill("#f3f3f3")
          .attr({ x:this.x+this.w/2, y:this.y+this.h/2, "text-anchor":"middle" });
      }

      _calcCenteredY(str){
        const cx=this.x+this.w/2;
        const targetCy=this.y+this.h/2;

        this.measure.text(str).attr({x:cx,y:0});
        const b=this.measure.bbox();
        const bboxCenter=b.y+b.height/2;

        return targetCy - bboxCenter + this.opticalNudge;
      }

      _setText(el,str){
        el.text(str);
        el.attr({ y:this._calcCenteredY(str) });
      }

      setValue(v){
        this.value=v;
        this._setText(this.topText,v);
        this._setText(this.botText,v);
        this._setText(this.flapText,v);
      }

      flipTo(next,dur=650){
        if(this.isFlipping||next===this.value) return;
        this.isFlipping=true;

        const cur=this.value;
        this._setText(this.topText,cur);
        this._setText(this.botText,cur);
        this._setText(this.flapText,cur);

        const start=performance.now();
        const cx=this.x+this.w/2;
        const hingeY=this.y+this.half;
        let switched=false;

        const step=(now)=>{
          const t=Math.min(1,(now-start)/dur);
          const e=easeInOutCubic(t);

          this.flap.transform({
            translateX:cx,
            translateY:hingeY,
            scaleY:1-e,
            scaleX:1
          });

          if(!switched && t>0.52){
            switched=true;
            this._setText(this.topText,next);
            this._setText(this.botText,next);
            this._setText(this.flapText,next);
          }

          if(t<1) requestAnimationFrame(step);
          else{
            this.flap.untransform();
            this.value=next;
            this.isFlipping=false;
          }
        };
        requestAnimationFrame(step);
      }
    }

    const DATE_LAYOUT_W = 560;
    const DATE_LAYOUT_H = 300;
    const DATE_SCALE = 0.3;
    const dateRoot = draw.group();
    const dateInner = dateRoot.group().scale(DATE_SCALE);

    const dateSvg = dateInner.nested()
      .viewbox(0,0,DATE_LAYOUT_W,DATE_LAYOUT_H)
      .size(DATE_LAYOUT_W, DATE_LAYOUT_H);

    dateSvg.rect(DATE_LAYOUT_W, DATE_LAYOUT_H).fill("none").opacity(0);

    const yearText = dateSvg.text("2025")
      .font({family:"Georgia,'Times New Roman',serif",size:44,weight:700})
      .fill("#1a1a1a")
      .attr({x:DATE_LAYOUT_W/2,y:78,"text-anchor":"middle","dominant-baseline":"middle"});

    const cardW=90,cardH=72,gap=14;
    const x0=(DATE_LAYOUT_W-(cardW*2+gap))/2;
    const y0=128;

    const OPTICAL_NUDGE = 5;

    const mm=new FlipUnit(dateSvg,x0,y0,cardW,cardH,{opticalNudge:OPTICAL_NUDGE});
    const dd=new FlipUnit(dateSvg,x0+cardW+gap,y0,cardW,cardH,{opticalNudge:OPTICAL_NUDGE});

    const dowText=dateSvg.text("金")
      .font({
        family:"'Hiragino Maru Gothic ProN','Rounded Mplus 1c','Yu Gothic UI','Meiryo',sans-serif",
        size:40,
        weight:600
      })
      .fill("rgba(0,0,0,.65)")
      .attr({
        x:x0+cardW*2+gap+28,
        y:y0+cardH/2,
        "text-anchor":"start",
        "dominant-baseline":"middle"
      });

    function setDow(d){
      const w=weekJP[d.getDay()];
      dowText.text(w);
      if(w==="土") dowText.fill(theme.sat);
      else if(w==="日") dowText.fill(theme.sun);
      else dowText.fill("rgba(0,0,0,.65)");
    }

    function setAll(d){
      yearText.text(d.getFullYear());
      mm.setValue(pad2(d.getMonth()+1));
      dd.setValue(pad2(d.getDate()));
      setDow(d);
    }

    let lastDateKey = null;
    const dateKey = d => `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;

    function updateDateOnChange(d){
      const k = dateKey(d);
      if(lastDateKey === null){
        setAll(d);
        lastDateKey = k;
        return;
      }
      if(lastDateKey !== k){
        const prev=new Date(d-1000);
        dd.flipTo(pad2(d.getDate()));
        if(prev.getMonth()!==d.getMonth()){
          setTimeout(()=>mm.flipTo(pad2(d.getMonth()+1)),220);
        }
        yearText.text(d.getFullYear());
        setDow(d);
        lastDateKey = k;
      }
    }

    function clampIntoView(margin=8){
      const b = dateRoot.bbox();
      let dx=0, dy=0;

      if(b.x < margin) dx = margin - b.x;
      if(b.y < margin) dy = margin - b.y;
      if(b.x2 > 400 - margin) dx = (400 - margin) - b.x2;
      if(b.y2 > 400 - margin) dy = (400 - margin) - b.y2;

      if(dx || dy) dateRoot.dmove(dx, dy);
    }

    function placeDateOutsideAngle(hrDeg, minDeg){
      const d = shortestDelta(minDeg, hrDeg);
      const innerMid = normDeg(minDeg + d/2);
      let outerMid = normDeg(innerMid + 180);

      const ANGLE_OFFSET = 10;
      outerMid = normDeg(outerMid + ANGLE_OFFSET);

      const r = dialR * 0.35;
      const p = polar(outerMid, r);

      dateRoot.center(p.x, p.y);
      clampIntoView(10);
    }

    /* ===== 針 ===== */
    const hands = draw.group()
      .attr({style:"filter:drop-shadow(0 1px 1px rgba(0,0,0,.25))"});

    function makeHand(w, l, color, radius=0){
      return hands.rect(w, l)
        .move(cx - w/2, cy - l)
        .fill(color)
        .radius(radius);
    }

    const hHand = makeHand(12, 100, theme.hour, 2);
    const mHand = makeHand( 6, 145, theme.minute, 2);

    const sHand = hands.group();
    sHand.rect(2, 155).move(cx - 1, cy - 145).fill(theme.second);
    sHand.rect(4,  44).move(cx - 2, cy +   5).fill(theme.second);

    draw.circle(14).center(cx,cy)
      .fill("#cfcfcf")
      .stroke({width:1, color:"rgba(0,0,0,.25)"});

    /* ===== tick ===== */
    function tickAlignedOncePerSecond(){
      const d = new Date();

      const sec = d.getSeconds();
      const min = d.getMinutes() + sec/60;
      const hr  = (d.getHours()%12) + min/60;

      const hrDeg  = hr * 30;
      const minDeg = min * 6;

      hHand.untransform().rotate(hrDeg,  cx, cy);
      mHand.untransform().rotate(minDeg, cx, cy);
      sHand.untransform().rotate(sec*6,  cx, cy);

      placeDateOutsideAngle(hrDeg, minDeg);
      updateDateOnChange(d);

      setTimeout(tickAlignedOncePerSecond, 1000 - d.getMilliseconds());
    }

    tickAlignedOncePerSecond();
  </script>
</body>
</html>
