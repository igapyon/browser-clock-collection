<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Analog Clock + Flip Date (stable centered)</title>
  <style>
    body{
      margin:0;
      min-height:100vh;
      display:grid;
      place-items:center;
      background:#ececec;
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif;
    }
    .wrap{
      display:grid;
      gap:10px;
      justify-items:center;
      padding:18px;
    }
    #mount{
      width:min(92vw, 420px);
      aspect-ratio:1/1;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div id="mount" aria-label="アナログ時計"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.2.4/dist/svg.min.js"></script>

  <script>
    const theme = {
      frame:"#8a4f3a",
      dial:"#f7f7f5",
      text:"#101010",
      dotMinor:"rgba(0,0,0,0.35)",
      dotMajor:"#1a1a1a",
      hour:"#111",
      minute:"#111",
      second:"#9aa0a6",

      card:"#1f1f1f",
      cardTop:"#262626",
      cardText:"#f3f3f3",
      seam:"rgba(255,255,255,.10)",
      shadow:"rgba(0,0,0,.25)",

      yearText:"#1a1a1a",
      dowText:"rgba(0,0,0,.55)",
      sat:"#1f4fd8",
      sun:"#d32f2f"
    };

    const weekJP = ["日","月","火","水","木","金","土"];
    const pad2 = (n) => String(n).padStart(2,"0");

    const draw = SVG().addTo("#mount").viewbox(0,0,400,400).size("100%","100%");
    const cx=200, cy=200;

    const polar = (deg, r) => {
      const a = deg * Math.PI / 180;
      return { x: cx + Math.sin(a)*r, y: cy - Math.cos(a)*r };
    };
    const normDeg = d => ((d % 360) + 360) % 360;
    const shortestDelta = (a, b) => {
      let d = normDeg(b) - normDeg(a);
      if(d > 180) d -= 360;
      if(d < -180) d += 360;
      return d;
    };

    /* ===== フレーム ===== */
    draw.circle(400).center(cx,cy).fill(theme.frame);
    draw.circle(392).center(cx,cy).fill("none")
      .stroke({width:4, color:"rgba(255,255,255,.1)"});
    draw.circle(392).center(cx,cy).fill("none")
      .stroke({width:10, color:"rgba(0,0,0,.22)"}).opacity(.35);

    /* ===== 文字盤 ===== */
    const dialR = 172;
    draw.circle(dialR*2).center(cx,cy)
      .fill(theme.dial)
      .stroke({width:1, color:"rgba(0,0,0,.1)"});

    /* ===== 目盛り ===== */
    const ticks = draw.group();
    for(let i=0;i<60;i++){
      const p = polar(i*6, dialR*0.92);
      ticks.circle(i%5===0 ? 5 : 3)
        .center(p.x,p.y)
        .fill(i%5===0 ? theme.dotMajor : theme.dotMinor);
    }

    /* ===== 数字 ===== */
    const nums = draw.group();
    const numberRadius = dialR * 0.74;
    const fontSize = 42;
    const globalDy = -fontSize * 0.05;
    const tightK = 0.27;
    const dx = fontSize * tightK;

    function drawNumber(n, x, y){
      const yy = y + globalDy;
      const font = {family:"Georgia,'Times New Roman',serif", size:fontSize, weight:700};
      if(n < 10){
        nums.text(String(n)).font(font).fill(theme.text)
          .attr({x, y:yy, "text-anchor":"middle", "dominant-baseline":"middle"});
        return;
      }
      const s = String(n);
      nums.text(s[0]).font(font).fill(theme.text)
        .attr({x:x-dx, y:yy, "text-anchor":"middle", "dominant-baseline":"middle"});
      nums.text(s[1]).font(font).fill(theme.text)
        .attr({x:x+dx, y:yy, "text-anchor":"middle", "dominant-baseline":"middle"});
    }
    for(let n=1;n<=12;n++){
      const p = polar((n%12)*30, numberRadius);
      drawNumber(n, p.x, p.y);
    }

    /* =========================================================
       Flip Date UI（flip-date と同じ比率で描画 → scale で縮小）
       ========================================================= */
    const DATE_SCALE = 0.55;
    const DATE_LAYOUT_W = 560;
    const DATE_LAYOUT_H = 300;
    const CARD_FONT_SIZE = 64;

    class FlipCard {
      constructor(parent, x, y, w, h, text){
        this.g = parent.group().move(x,y);
        const half = h/2;

        this.g.rect(w,h).move(2,3)
          .fill(theme.shadow).radius(10).opacity(.35);

        this.g.rect(w,h).move(0,0).fill(theme.card).radius(10);
        this.g.rect(w,half).move(0,0).fill(theme.cardTop).radius(10);

        this.g.line(10, half+0.5, w-10, half+0.5)
          .stroke({width:1, color:theme.seam});

        this.t = this.g.text(text)
          .font({family:"ui-monospace, Menlo, Consolas, monospace", size:CARD_FONT_SIZE, weight:700})
          .fill(theme.cardText)
          .attr({x:w/2, y:h/2, "text-anchor":"middle", "dominant-baseline":"middle"});
      }
      set(v){ this.t.text(v); }
    }

    // 外側：毎秒 center() するだけ
    const dateRoot = draw.group();

    // 内側：固定レイアウト + scale はここだけ
    const dateInner = dateRoot.group().scale(DATE_SCALE);

    // 固定レイアウトの bbox を安定させる（年や曜日で幅が変わっても中心がズレない）
    dateInner.rect(DATE_LAYOUT_W, DATE_LAYOUT_H).fill("none").opacity(0);

    const cardW = 150, cardH = 120, cardGap = 24;
    const x0 = (DATE_LAYOUT_W - (cardW * 2 + cardGap)) / 2;
    const cardsY = 90;
    const yearY = 52;

    const yearText = dateInner.text("2025")
      .font({family:"Georgia,'Times New Roman',serif", size:44, weight:700})
      .fill(theme.yearText)
      .attr({
        x: DATE_LAYOUT_W/2,
        y: yearY,
        "text-anchor":"middle",
        "dominant-baseline":"middle"
      });

    const mmCard = new FlipCard(dateInner, x0, cardsY, cardW, cardH, "12");
    const ddCard = new FlipCard(dateInner, x0 + cardW + cardGap, cardsY, cardW, cardH, "26");

    const dowText = dateInner.text("金")
      .font({
        family:"'Hiragino Maru Gothic ProN','Rounded Mplus 1c','Yu Gothic UI','Meiryo',sans-serif",
        size:40, weight:600
      })
      .fill(theme.dowText)
      .attr({
        x: x0 + cardW * 2 + cardGap + 28,
        y: cardsY + cardH/2,
        "text-anchor":"start",
        "dominant-baseline":"middle"
      });

    function setDate(d){
      const y = d.getFullYear();
      const m = pad2(d.getMonth()+1);
      const day = pad2(d.getDate());
      const w = weekJP[d.getDay()];

      yearText.text(String(y));
      mmCard.set(m);
      ddCard.set(day);
      dowText.text(w);

      if(w==="土") dowText.fill(theme.sat);
      else if(w==="日") dowText.fill(theme.sun);
      else dowText.fill(theme.dowText);
    }
    setDate(new Date());

    // viewBox 内に収める（欠け防止）
    function clampIntoView(margin=8){
      const b = dateRoot.bbox();
      let dx=0, dy=0;

      if(b.x < margin) dx = margin - b.x;
      if(b.y < margin) dy = margin - b.y;
      if(b.x2 > 400 - margin) dx = (400 - margin) - b.x2;
      if(b.y2 > 400 - margin) dy = (400 - margin) - b.y2;

      if(dx || dy) dateRoot.dmove(dx, dy);
    }

    function placeDateOutsideAngle(hrDeg, minDeg){
      const d = shortestDelta(minDeg, hrDeg);
      const innerMid = normDeg(minDeg + d/2);
      let outerMid = normDeg(innerMid + 180);

      const ANGLE_OFFSET = 10;
      outerMid = normDeg(outerMid + ANGLE_OFFSET);

      const r = dialR * 0.62;
      const p = polar(outerMid, r);

      // ★ここが本質：bbox中心を p に合わせる
      dateRoot.center(p.x, p.y);

      // ★欠け防止
      clampIntoView(10);
    }

    /* ===== 針 ===== */
    const hands = draw.group()
      .attr({style:"filter:drop-shadow(0 1px 1px rgba(0,0,0,.25))"});

    function makeHand(w, l, color, radius=0){
      return hands.rect(w, l)
        .move(cx - w/2, cy - l)
        .fill(color)
        .radius(radius);
    }

    const hHand = makeHand(12, 100, theme.hour, 2);
    const mHand = makeHand( 6, 145, theme.minute, 2);

    const sHand = hands.group();
    sHand.rect(2, 155).move(cx - 1, cy - 145).fill(theme.second);
    sHand.rect(4,  44).move(cx - 2, cy +   5).fill(theme.second);

    draw.circle(14).center(cx,cy)
      .fill("#cfcfcf")
      .stroke({width:1, color:"rgba(0,0,0,.25)"});

    /* ===== tick ===== */
    let lastDateKey = null;
    const dateKey = d => `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;

    function tickAlignedOncePerSecond(){
      const d = new Date();

      const sec = d.getSeconds();
      const min = d.getMinutes() + sec/60;
      const hr  = (d.getHours()%12) + min/60;

      const hrDeg  = hr * 30;
      const minDeg = min * 6;

      hHand.untransform().rotate(hrDeg,  cx, cy);
      mHand.untransform().rotate(minDeg, cx, cy);
      sHand.untransform().rotate(sec * 6, cx, cy);

      placeDateOutsideAngle(hrDeg, minDeg);

      const k = dateKey(d);
      if(lastDateKey !== k){
        setDate(d);
        lastDateKey = k;
      }

      setTimeout(tickAlignedOncePerSecond, 1000 - d.getMilliseconds());
    }
    tickAlignedOncePerSecond();
  </script>
</body>
</html>
