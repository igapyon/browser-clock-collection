<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Analog Clock + Date (outside angle)</title>
  <style>
    body{
      margin:0;
      min-height:100vh;
      display:grid;
      place-items:center;
      background:#ececec;
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif;
    }
    .wrap{
      display:grid;
      gap:10px;
      justify-items:center;
      padding:18px;
    }
    #mount{
      width:min(92vw, 420px);
      aspect-ratio:1/1;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div id="mount" aria-label="アナログ時計"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.2.4/dist/svg.min.js"></script>

  <script>
    /* ===== テーマ ===== */
    const theme = {
      frame:"#8a4f3a",
      dial:"#f7f7f5",
      text:"#101010",
      dotMinor:"rgba(0,0,0,0.35)",
      dotMajor:"#1a1a1a",
      hour:"#111",
      minute:"#111",
      second:"#9aa0a6",
      dateText:"rgba(0,0,0,0.70)",
      dateSub:"rgba(0,0,0,0.55)",
      sat:"#1f4fd8",
      sun:"#d32f2f"
    };

    const weekJP = ["日","月","火","水","木","金","土"];
    const pad2 = (n) => String(n).padStart(2,"0");

    const cfg = {
      base: 400,
      frameInset: 8,
      frameHighlight: 4,
      frameShadow: 10,
      dialR: 172,
      tickRadiusRatio: 0.92,
      tickMajor: 5,
      tickMinor: 3,
      numberRadiusRatio: 0.74,
      numberFont: 42,
      numberTightK: 0.27,
      hand: {
        hourW: 12,
        hourL: 100,
        minW: 6,
        minL: 145,
        secW: 2,
        secL: 155,
        secTailW: 4,
        secTailL: 44,
        secTailOffsetY: 5
      },
      centerDot: 14,
      date: {
        layoutW: 560,
        layoutH: 300,
        scale: 0.3,
        yearFont: 44,
        yearY: 78,
        cardW: 90,
        cardH: 72,
        cardGap: 14,
        cardY: 128,
        dowFont: 36,
        dowX: 11,
        dowY: 15,
        opticalNudge: 5,
        angleOffset: 10,
        radiusRatio: 0.32,
        clampMargin: 10
      }
    };

    const BASE = cfg.base;
    const S = BASE / 400;
    const draw = SVG()
      .addTo("#mount")
      .viewbox(0,0,BASE,BASE)
      .size("100%","100%");

    const cx = BASE / 2;
    const cy = BASE / 2;

    const polar = (deg, r) => {
      const a = deg * Math.PI / 180;
      return { x: cx + Math.sin(a) * r, y: cy - Math.cos(a) * r };
    };

    const normDeg = d => ((d % 360) + 360) % 360;

    const shortestDelta = (a, b) => {
      let d = normDeg(b) - normDeg(a);
      if (d > 180) d -= 360;
      if (d < -180) d += 360;
      return d;
    };

    /* ===== フレーム ===== */
    draw.circle(BASE).center(cx,cy).fill(theme.frame);
    draw.circle(BASE - cfg.frameInset * S).center(cx,cy).fill("none")
      .stroke({width:cfg.frameHighlight * S, color:"rgba(255,255,255,.1)"});
    draw.circle(BASE - cfg.frameInset * S).center(cx,cy).fill("none")
      .stroke({width:cfg.frameShadow * S, color:"rgba(0,0,0,.22)"}).opacity(.35);

    /* ===== 文字盤 ===== */
    const dialR = cfg.dialR * S;
    draw.circle(dialR*2).center(cx,cy)
      .fill(theme.dial)
      .stroke({width:1, color:"rgba(0,0,0,.1)"});

    /* ===== 目盛り ===== */
    const ticks = draw.group();
    for(let i=0;i<60;i++){
      const p = polar(i*6, dialR * cfg.tickRadiusRatio);
      ticks.circle(i%5===0 ? cfg.tickMajor * S : cfg.tickMinor * S)
        .center(p.x, p.y)
        .fill(i%5===0 ? theme.dotMajor : theme.dotMinor);
    }

    /* ===== 数字 ===== */
    const nums = draw.group();
    const numberRadius = dialR * cfg.numberRadiusRatio;
    const fontSize = cfg.numberFont * S;
    const globalDy = -fontSize * 0.05;
    const tightK = cfg.numberTightK;
    const dx = fontSize * tightK;

    function drawNumber(n, x, y){
      const yy = y + globalDy;
      if(n < 10){
        nums.text(String(n))
          .font({family:"Georgia,'Times New Roman',serif", size:fontSize, weight:700})
          .fill(theme.text)
          .attr({x, y:yy, "text-anchor":"middle", "dominant-baseline":"middle"});
        return;
      }
      const s = String(n);
      nums.text(s[0])
        .font({family:"Georgia,'Times New Roman',serif", size:fontSize, weight:700})
        .fill(theme.text)
        .attr({x:x-dx, y:yy, "text-anchor":"middle", "dominant-baseline":"middle"});
      nums.text(s[1])
        .font({family:"Georgia,'Times New Roman',serif", size:fontSize, weight:700})
        .fill(theme.text)
        .attr({x:x+dx, y:yy, "text-anchor":"middle", "dominant-baseline":"middle"});
    }

    for(let n=1;n<=12;n++){
      const p = polar((n%12)*30, numberRadius);
      drawNumber(n, p.x, p.y);
    }

    /* ===== Flip Date Mini（外角側） ===== */
    function easeInOutCubic(t){
      return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
    }

    class FlipUnit{
      constructor(draw, x, y, w, h, opts={}){
        this.draw=draw; this.x=x; this.y=y; this.w=w; this.h=h;
        this.half=h/2;
        this.value="00";
        this.isFlipping=false;

        this.opticalNudge = opts.opticalNudge ?? 5;

        draw.rect(w,h).move(x+2,y+3)
          .fill("rgba(0,0,0,.25)").radius(6).opacity(.35);

        this.card=draw.group();
        this.card.rect(w,h).move(x,y).fill("#1f1f1f").radius(6);
        this.card.rect(w,this.half).move(x,y).fill("#262626").radius(6);

        const seamY = y + this.half + 0.5;
        this.card.line(x+6,seamY,x+w-6,seamY)
          .stroke({width:1,color:"rgba(255,255,255,.1)"});

        this.clipTop=draw.clip().add(draw.rect(w,this.half).move(x,y));
        this.clipBot=draw.clip().add(draw.rect(w,this.half).move(x,y+this.half));

        this.topStatic=draw.group().clipWith(this.clipTop);
        this.botStatic=draw.group().clipWith(this.clipBot);
        this.flap=draw.group().clipWith(this.clipTop);

        this.font={ family:"ui-monospace, Menlo, Consolas, monospace", size:38, weight:700 };

        this.measure = draw.text("00")
          .font(this.font)
          .fill("none")
          .opacity(0)
          .attr({ x:this.x+this.w/2, y:0, "text-anchor":"middle" });

        this.topText=this._txt(this.topStatic,this.value);
        this.botText=this._txt(this.botStatic,this.value);
        this.flapText=this._txt(this.flap,this.value);

        this._setText(this.topText,this.value);
        this._setText(this.botText,this.value);
        this._setText(this.flapText,this.value);
      }

      _txt(g,str){
        return g.text(str)
          .font(this.font)
          .fill("#f3f3f3")
          .attr({ x:this.x+this.w/2, y:this.y+this.h/2, "text-anchor":"middle" });
      }

      _calcCenteredY(str){
        const cx=this.x+this.w/2;
        const targetCy=this.y+this.h/2;

        this.measure.text(str).attr({x:cx,y:0});
        const b=this.measure.bbox();
        const bboxCenter=b.y+b.height/2;

        return targetCy - bboxCenter + this.opticalNudge;
      }

      _setText(el,str){
        el.text(str);
        el.attr({ y:this._calcCenteredY(str) });
      }

      setValue(v){
        this.value=v;
        this._setText(this.topText,v);
        this._setText(this.botText,v);
        this._setText(this.flapText,v);
      }

      flipTo(next,dur=650){
        if(this.isFlipping||next===this.value) return;
        this.isFlipping=true;

        const cur=this.value;
        this._setText(this.topText,cur);
        this._setText(this.botText,cur);
        this._setText(this.flapText,cur);

        const start=performance.now();
        const cx=this.x+this.w/2;
        const hingeY=this.y+this.half;
        let switched=false;

        const step=(now)=>{
          const t=Math.min(1,(now-start)/dur);
          const e=easeInOutCubic(t);

          this.flap.transform({
            translateX:cx,
            translateY:hingeY,
            scaleY:1-e,
            scaleX:1
          });

          if(!switched && t>0.52){
            switched=true;
            this._setText(this.topText,next);
            this._setText(this.botText,next);
            this._setText(this.flapText,next);
          }

          if(t<1) requestAnimationFrame(step);
          else{
            this.flap.untransform();
            this.value=next;
            this.isFlipping=false;
          }
        };
        requestAnimationFrame(step);
      }
    }

    function createFlipDateMini(draw, opts = {}){
      const DATE_LAYOUT_W = cfg.date.layoutW;
      const DATE_LAYOUT_H = cfg.date.layoutH;
      const DATE_SCALE = (opts.dateScale ?? cfg.date.scale) * S;

      const dateRoot = draw.group();
      const dateInner = dateRoot.group().scale(DATE_SCALE);

      const dateSvg = dateInner.nested()
        .viewbox(0,0,DATE_LAYOUT_W,DATE_LAYOUT_H)
        .size(DATE_LAYOUT_W, DATE_LAYOUT_H);

      dateSvg.rect(DATE_LAYOUT_W, DATE_LAYOUT_H).fill("none").opacity(0);

      const yearText = dateSvg.text("2025")
        .font({family:"Georgia,'Times New Roman',serif",size:cfg.date.yearFont * S,weight:700})
        .fill("#1a1a1a")
        .attr({
          x: DATE_LAYOUT_W/2,
          y: cfg.date.yearY * S,
          "text-anchor":"middle",
          "dominant-baseline":"middle"
        });

      const cardW = cfg.date.cardW * S;
      const cardH = cfg.date.cardH * S;
      const gap = cfg.date.cardGap * S;
      const x0=(DATE_LAYOUT_W-(cardW*2+gap))/2;
      const y0 = cfg.date.cardY * S;

      const OPTICAL_NUDGE = cfg.date.opticalNudge;

      const mm=new FlipUnit(dateSvg,x0,y0,cardW,cardH,{opticalNudge:OPTICAL_NUDGE});
      const dd=new FlipUnit(dateSvg,x0+cardW+gap,y0,cardW,cardH,{opticalNudge:OPTICAL_NUDGE});

      const dowText=dateSvg.text("金")
        .font({
          family:"'Hiragino Maru Gothic ProN','Rounded Mplus 1c','Yu Gothic UI','Meiryo',sans-serif",
          size:cfg.date.dowFont * S,
          weight:600
        })
        .fill("rgba(0,0,0,.65)")
        .attr({
          x: x0 + cardW * 2 + gap + cfg.date.dowX * S,
          y: y0 + cardH/2 + cfg.date.dowY * S,
          "text-anchor":"start",
          "dominant-baseline":"middle"
        });

      function setDow(d){
        const w=weekJP[d.getDay()];
        dowText.text(w);
        if(w==="土") dowText.fill(theme.sat);
        else if(w==="日") dowText.fill(theme.sun);
        else dowText.fill("rgba(0,0,0,.65)");
      }

      function setAll(d){
        yearText.text(d.getFullYear());
        mm.setValue(pad2(d.getMonth()+1));
        dd.setValue(pad2(d.getDate()));
        setDow(d);
      }

      let lastDateKey = null;
      const dateKey = d => `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;

      function updateDateOnChange(d){
        const k = dateKey(d);
        if(lastDateKey === null){
          setAll(d);
          lastDateKey = k;
          return;
        }
        if(lastDateKey !== k){
          const prev=new Date(d-1000);
          dd.flipTo(pad2(d.getDate()));
          if(prev.getMonth()!==d.getMonth()){
            setTimeout(()=>mm.flipTo(pad2(d.getMonth()+1)),220);
          }
          yearText.text(d.getFullYear());
          setDow(d);
          lastDateKey = k;
        }
      }

      function clampIntoView(margin=cfg.date.clampMargin){
        const b = dateRoot.bbox();
        let dx=0, dy=0;

        if(b.x < margin) dx = margin - b.x;
        if(b.y < margin) dy = margin - b.y;
        if(b.x2 > BASE - margin) dx = (BASE - margin) - b.x2;
        if(b.y2 > BASE - margin) dy = (BASE - margin) - b.y2;

        if(dx || dy) dateRoot.dmove(dx, dy);
      }

      function placeDateOutsideAngle(hrDeg, minDeg){
        const d = shortestDelta(minDeg, hrDeg);
        const innerMid = normDeg(minDeg + d/2);
        let outerMid = normDeg(innerMid + 180);

        const ANGLE_OFFSET = cfg.date.angleOffset;
        outerMid = normDeg(outerMid + ANGLE_OFFSET);

        const r = dialR * cfg.date.radiusRatio;
        const p = polar(outerMid, r);

        dateRoot.center(p.x, p.y);
        clampIntoView();
      }

      return {
        updateDateOnChange,
        placeDateOutsideAngle
      };
    }

    const dateMini = createFlipDateMini(draw, { dateScale: 0.3 });

    /* ===== 針 ===== */
    const hands = draw.group()
      .attr({style:"filter:drop-shadow(0 1px 1px rgba(0,0,0,.25))"});

    function makeHand(w, l, color, radius=0){
      return hands.rect(w, l)
        .move(cx - w/2, cy - l)
        .fill(color)
        .radius(radius);
    }

    const hHand = makeHand(cfg.hand.hourW * S, cfg.hand.hourL * S, theme.hour, 2 * S);
    const mHand = makeHand(cfg.hand.minW * S, cfg.hand.minL * S, theme.minute, 2 * S);

    const sHand = hands.group();
    sHand.rect(cfg.hand.secW * S, cfg.hand.secL * S)
      .move(cx - (cfg.hand.secW / 2) * S, cy - (cfg.hand.secL - 10) * S)
      .fill(theme.second);
    sHand.rect(cfg.hand.secTailW * S, cfg.hand.secTailL * S)
      .move(cx - (cfg.hand.secTailW / 2) * S, cy + cfg.hand.secTailOffsetY * S)
      .fill(theme.second);

    draw.circle(cfg.centerDot * S).center(cx,cy)
      .fill("#cfcfcf")
      .stroke({width:1 * S, color:"rgba(0,0,0,.25)"});

    /* ===== tick ===== */
    function tickAlignedOncePerSecond(){
      const d = new Date();

      const sec = d.getSeconds();
      const min = d.getMinutes() + sec/60;
      const hr  = (d.getHours()%12) + min/60;

      const hrDeg  = hr * 30;
      const minDeg = min * 6;

      hHand.untransform().rotate(hrDeg,  cx, cy);
      mHand.untransform().rotate(minDeg, cx, cy);
      sHand.untransform().rotate(sec*6,  cx, cy);

      dateMini.placeDateOutsideAngle(hrDeg, minDeg);
      dateMini.updateDateOnChange(d);

      setTimeout(tickAlignedOncePerSecond, 1000 - d.getMilliseconds());
    }

    tickAlignedOncePerSecond();
  </script>
</body>
</html>
