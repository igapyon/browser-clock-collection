<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Analog Clock (svg.js)</title>
  <style>
    body{
      margin:0;
      min-height:100vh;
      display:grid;
      place-items:center;
      background:#ececec;
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif;
    }
    .wrap{
      display:grid;
      gap:10px;
      justify-items:center;
      padding:0;
    }
    #mount{
      width:min(100vw, 100vh);
      height:min(100vw, 100vh);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div id="mount" aria-label="アナログ時計"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.2.4/dist/svg.min.js"></script>

  <script>
    const weekJP = ["日","月","火","水","木","金","土"];
    const pad2 = (n) => String(n).padStart(2,"0");

    const cfg = Object.freeze({
      // Theme
      theme: Object.freeze({
        frame:"#8a4f3a",
        dial:"#f7f7f5",
        text:"#101010",
        dotMinor:"rgba(0,0,0,0.35)",
        dotMajor:"#1a1a1a",
        hour:"#111",
        minute:"#111",
        second:"#9aa0a6",
        dateText:"rgba(0,0,0,0.70)",
        dateSub:"rgba(0,0,0,0.55)",
        sat:"#1f4fd8",
        sun:"#d32f2f"
      }),

      // Base size for proportional scaling
      base: 400,
      baseMin: 240,
      baseScale: 0.9,

      // Frame + dial
      frameInset: 8,
      frameHighlight: 4,
      frameShadow: 10,
      dialR: 172,

      // Ticks + numbers
      tickRadiusRatio: 0.92,
      tickMajor: 5,
      tickMinor: 3,
      numberRadiusRatio: 0.74,
      numberFont: 42,
      numberTightK: 0.27,

      // Hands
      hand: Object.freeze({
        hourW: 12,
        hourL: 100,
        minW: 6,
        minL: 145,
        secW: 2,
        secL: 155,
        secTailW: 4,
        secTailL: 44,
        secTailOffsetY: 5
      }),
      centerDot: 14,

      // Flip date mini
      date: Object.freeze({
        layoutW: 560,
        layoutH: 300,
        scale: 0.3,
        yearFont: 44,
        yearY: 78,
        cardW: 90,
        cardH: 72,
        cardGap: 14,
        cardY: 128,
        dowFont: 32,
        ampmFont: 26,
        dowX: 18,
        dowY: -18,
        ampmY: 24,
        opticalNudge: 5,
        angleOffset: 10,
        radiusRatio: 0.32,
        clampMargin: 10
      })
    });

    const theme = cfg.theme;

    const draw = SVG()
      .addTo("#mount")
      .size("100%","100%");

    function computeBase(){
      const size = Math.min(window.innerWidth, window.innerHeight);
      const cssBase = Math.max(cfg.baseMin, Math.floor(size * cfg.baseScale));
      const dpr = window.devicePixelRatio || 1;
      const base = Math.round(cssBase * dpr);
      return { base, cssBase, dpr };
    }

    function applyBase(baseInfo){
      const scale = baseInfo.base / 400;
      return {
        base: baseInfo.base,
        scale,
        cx: baseInfo.base / 2,
        cy: baseInfo.base / 2,
        cssBase: baseInfo.cssBase,
        dpr: baseInfo.dpr
      };
    }

    let metrics = applyBase(computeBase());

    const polar = (deg, r) => {
      const a = deg * Math.PI / 180;
      return {
        x: metrics.cx + Math.sin(a) * r,
        y: metrics.cy - Math.cos(a) * r
      };
    };

    const normDeg = d => ((d % 360) + 360) % 360;

    const shortestDelta = (a, b) => {
      let d = normDeg(b) - normDeg(a);
      if (d > 180) d -= 360;
      if (d < -180) d += 360;
      return d;
    };

    const gFrame = draw.group();
    const ticks = draw.group();
    const nums = draw.group();
    let dialR = 0;

    function drawFrame(){
      gFrame.clear();
      const { base, scale, cx, cy } = metrics;
      dialR = cfg.dialR * scale;

      gFrame.circle(base).center(cx,cy).fill(theme.frame);
      gFrame.circle(base - cfg.frameInset * scale).center(cx,cy).fill("none")
        .stroke({width:cfg.frameHighlight * scale, color:"rgba(255,255,255,.1)"});
      gFrame.circle(base - cfg.frameInset * scale).center(cx,cy).fill("none")
        .stroke({width:cfg.frameShadow * scale, color:"rgba(0,0,0,.22)"}).opacity(.35);

      gFrame.circle(dialR*2).center(cx,cy)
        .fill(theme.dial)
        .stroke({width:1 * scale, color:"rgba(0,0,0,.1)"});
    }

    function drawTicksAndNumbers(){
      ticks.clear();
      nums.clear();
      const { scale } = metrics;
      const numberRadius = dialR * cfg.numberRadiusRatio;
      const fontSize = cfg.numberFont * scale;
      const globalDy = -fontSize * 0.05;
      const tightK = cfg.numberTightK;
      const dx = fontSize * tightK;

      function drawNumber(n, x, y){
        const yy = y + globalDy;
        if(n < 10){
          nums.text(String(n))
            .font({family:"Georgia,'Times New Roman',serif", size:fontSize, weight:700})
            .fill(theme.text)
            .attr({x, y:yy, "text-anchor":"middle", "dominant-baseline":"middle"});
          return;
        }
        const s = String(n);
        nums.text(s[0])
          .font({family:"Georgia,'Times New Roman',serif", size:fontSize, weight:700})
          .fill(theme.text)
          .attr({x:x-dx, y:yy, "text-anchor":"middle", "dominant-baseline":"middle"});
        nums.text(s[1])
          .font({family:"Georgia,'Times New Roman',serif", size:fontSize, weight:700})
          .fill(theme.text)
          .attr({x:x+dx, y:yy, "text-anchor":"middle", "dominant-baseline":"middle"});
      }

      for(let i=0;i<60;i++){
        const p = polar(i*6, dialR * cfg.tickRadiusRatio);
        ticks.circle(i%5===0 ? cfg.tickMajor * scale : cfg.tickMinor * scale)
          .center(p.x, p.y)
          .fill(i%5===0 ? theme.dotMajor : theme.dotMinor);
      }

      for(let n=1;n<=12;n++){
        const p = polar((n%12)*30, numberRadius);
        drawNumber(n, p.x, p.y);
      }
    }

    /* ===== Flip Date Mini（外角側） ===== */
    function easeInOutCubic(t){
      return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
    }

    class FlipUnit{
      constructor(draw, x, y, w, h, opts={}){
        this.draw=draw; this.x=x; this.y=y; this.w=w; this.h=h;
        this.half=h/2;
        this.value="00";
        this.isFlipping=false;

        this.opticalNudge = opts.opticalNudge ?? 5;

        draw.rect(w,h).move(x+2,y+3)
          .fill("rgba(0,0,0,.25)").radius(6).opacity(.35);

        this.card=draw.group();
        this.card.rect(w,h).move(x,y).fill("#1f1f1f").radius(6);
        this.card.rect(w,this.half).move(x,y).fill("#262626").radius(6);

        const seamY = y + this.half + 0.5;
        this.card.line(x+6,seamY,x+w-6,seamY)
          .stroke({width:1,color:"rgba(255,255,255,.1)"});

        this.clipTop=draw.clip().add(draw.rect(w,this.half).move(x,y));
        this.clipBot=draw.clip().add(draw.rect(w,this.half).move(x,y+this.half));

        this.topStatic=draw.group().clipWith(this.clipTop);
        this.botStatic=draw.group().clipWith(this.clipBot);
        this.flap=draw.group().clipWith(this.clipTop);

        this.font={ family:"ui-monospace, Menlo, Consolas, monospace", size:38, weight:700 };

        this.measure = draw.text("00")
          .font(this.font)
          .fill("none")
          .opacity(0)
          .attr({ x:this.x+this.w/2, y:0, "text-anchor":"middle" });

        this.topText=this._txt(this.topStatic,this.value);
        this.botText=this._txt(this.botStatic,this.value);
        this.flapText=this._txt(this.flap,this.value);

        this._setText(this.topText,this.value);
        this._setText(this.botText,this.value);
        this._setText(this.flapText,this.value);
      }

      _txt(g,str){
        return g.text(str)
          .font(this.font)
          .fill("#f3f3f3")
          .attr({ x:this.x+this.w/2, y:this.y+this.h/2, "text-anchor":"middle" });
      }

      _calcCenteredY(str){
        const cx=this.x+this.w/2;
        const targetCy=this.y+this.h/2;

        this.measure.text(str).attr({x:cx,y:0});
        const b=this.measure.bbox();
        const bboxCenter=b.y+b.height/2;

        return targetCy - bboxCenter + this.opticalNudge;
      }

      _setText(el,str){
        el.text(str);
        el.attr({ y:this._calcCenteredY(str) });
      }

      setValue(v){
        this.value=v;
        this._setText(this.topText,v);
        this._setText(this.botText,v);
        this._setText(this.flapText,v);
      }

      flipTo(next,dur=650){
        if(this.isFlipping||next===this.value) return;
        this.isFlipping=true;

        const cur=this.value;
        this._setText(this.topText,cur);
        this._setText(this.botText,cur);
        this._setText(this.flapText,cur);

        const start=performance.now();
        const cx=this.x+this.w/2;
        const hingeY=this.y+this.half;
        let switched=false;

        const step=(now)=>{
          const t=Math.min(1,(now-start)/dur);
          const e=easeInOutCubic(t);

          this.flap.transform({
            translateX:cx,
            translateY:hingeY,
            scaleY:1-e,
            scaleX:1
          });

          if(!switched && t>0.52){
            switched=true;
            this._setText(this.topText,next);
            this._setText(this.botText,next);
            this._setText(this.flapText,next);
          }

          if(t<1) requestAnimationFrame(step);
          else{
            this.flap.untransform();
            this.value=next;
            this.isFlipping=false;
          }
        };
        requestAnimationFrame(step);
      }
    }

    function createFlipDateMini(draw, opts = {}){
      const cfgDate = cfg.date;
      const DATE_LAYOUT_W = cfgDate.layoutW;
      const DATE_LAYOUT_H = cfgDate.layoutH;
      const DATE_SCALE = opts.dateScale ?? cfgDate.scale;

      const dateRoot = draw.group();
      let dateInner;
      let yearText;
      let mm;
      let dd;
      let dowText;
      let ampmText;
      let ampmBadge;

      function build(){
        dateRoot.clear();
        dateInner = dateRoot.group();

        const dateSvg = dateInner.nested()
          .viewbox(0,0,DATE_LAYOUT_W,DATE_LAYOUT_H)
          .size(DATE_LAYOUT_W, DATE_LAYOUT_H);

        dateSvg.rect(DATE_LAYOUT_W, DATE_LAYOUT_H).fill("none").opacity(0);

        yearText = dateSvg.text("2025")
          .font({family:"Georgia,'Times New Roman',serif",size:cfgDate.yearFont,weight:700})
          .fill("#1a1a1a")
          .attr({
            x: DATE_LAYOUT_W/2,
            y: cfgDate.yearY,
            "text-anchor":"middle",
            "dominant-baseline":"middle"
          });

        const cardW = cfgDate.cardW;
        const cardH = cfgDate.cardH;
        const gap = cfgDate.cardGap;
        const x0=(DATE_LAYOUT_W-(cardW*2+gap))/2;
        const y0 = cfgDate.cardY;

        const OPTICAL_NUDGE = cfgDate.opticalNudge;

        mm = new FlipUnit(dateSvg,x0,y0,cardW,cardH,{opticalNudge:OPTICAL_NUDGE});
        dd = new FlipUnit(dateSvg,x0+cardW+gap,y0,cardW,cardH,{opticalNudge:OPTICAL_NUDGE});

        dowText = dateSvg.text("金")
          .font({
            family:"'Hiragino Maru Gothic ProN','Rounded Mplus 1c','Yu Gothic UI','Meiryo',sans-serif",
            size:cfgDate.dowFont,
            weight:600
          })
          .fill("rgba(0,0,0,.65)")
          .attr({
            x: x0 + cardW * 2 + gap + cfgDate.dowX,
            y: y0 + cardH/2 + cfgDate.dowY,
            "text-anchor":"start",
            "dominant-baseline":"middle"
          });

        ampmBadge = dateSvg.rect(10, 10)
          .radius(6)
          .fill("#e38a4a")
          .attr({
            x: x0 + cardW * 2 + gap + cfgDate.dowX,
            y: y0 + cardH/2 + cfgDate.ampmY,
            "shape-rendering":"geometricPrecision"
          });

        ampmText = dateSvg.text("AM")
          .font({
            family:"'Hiragino Maru Gothic ProN','Rounded Mplus 1c','Yu Gothic UI','Meiryo',sans-serif",
            size:cfgDate.ampmFont,
            weight:600
          })
          .fill("#fff")
          .attr({
            x: x0 + cardW * 2 + gap + cfgDate.dowX,
            y: y0 + cardH/2 + cfgDate.ampmY,
            "text-anchor":"start",
            "dominant-baseline":"middle"
          });
      }

      build();

      function setDowLabel(d){
        const w=weekJP[d.getDay()];
        dowText.text(w);
        if(w==="土") dowText.fill(theme.sat);
        else if(w==="日") dowText.fill(theme.sun);
        else dowText.fill("rgba(0,0,0,.65)");
      }

      function setAmPmLabel(d){
        const isPm = d.getHours() >= 12;
        ampmText.text(isPm ? "PM" : "AM");
        ampmBadge.fill(isPm ? "#2f6fd6" : "#e38a4a");

        const b = ampmText.bbox();
        const padX = 8;
        const padY = 4;
        ampmBadge
          .size(b.width + padX * 2, b.height + padY * 2)
          .move(b.x - padX, b.y - padY);
      }

      function setAllFields(d){
        yearText.text(d.getFullYear());
        mm.setValue(pad2(d.getMonth()+1));
        dd.setValue(pad2(d.getDate()));
        setDowLabel(d);
        setAmPmLabel(d);
      }

      let lastDateKey = null;
      const dateKey = d => `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;

      function updateDateIfNeeded(d){
        const k = dateKey(d);
        if(lastDateKey === null){
          setAllFields(d);
          lastDateKey = k;
          return;
        }
        if(lastDateKey !== k){
          const prev=new Date(d-1000);
          dd.flipTo(pad2(d.getDate()));
          if(prev.getMonth()!==d.getMonth()){
            setTimeout(()=>mm.flipTo(pad2(d.getMonth()+1)),220);
          }
          yearText.text(d.getFullYear());
          setDowLabel(d);
          setAmPmLabel(d);
          lastDateKey = k;
        }
      }

      function clampIntoView(margin=cfgDate.clampMargin){
        const b = dateRoot.bbox();
        let dx=0, dy=0;

        if(b.x < margin) dx = margin - b.x;
        if(b.y < margin) dy = margin - b.y;
        if(b.x2 > metrics.base - margin) dx = (metrics.base - margin) - b.x2;
        if(b.y2 > metrics.base - margin) dy = (metrics.base - margin) - b.y2;

        if(dx || dy) dateRoot.dmove(dx, dy);
      }

      function placeDateOutsideAngle(hrDeg, minDeg){
        const d = shortestDelta(minDeg, hrDeg);
        const innerMid = normDeg(minDeg + d/2);
        let outerMid = normDeg(innerMid + 180);

        const ANGLE_OFFSET = cfgDate.angleOffset;
        outerMid = normDeg(outerMid + ANGLE_OFFSET);

        const r = dialR * cfgDate.radiusRatio;
        const p = polar(outerMid, r);

        dateRoot.center(p.x, p.y);
        clampIntoView();
      }

      return {
        updateDateIfNeeded,
        updateTimeFields(d){
          setAmPmLabel(d);
        },
        placeDateOutsideAngle,
        setScale(scale){
          dateInner.untransform().scale(scale * DATE_SCALE);
        },
        rebuild(){
          build();
          lastDateKey = null;
        },
        setAllNow(d){
          setAllFields(d);
          lastDateKey = dateKey(d);
        }
      };
    }

    const dateMini = createFlipDateMini(draw, { dateScale: 0.3 });

    /* ===== 針 ===== */
    function createHands(draw){
      const hands = draw.group()
        .attr({style:"filter:drop-shadow(0 1px 1px rgba(0,0,0,.25))"});

      const hHand = hands.rect(0, 0).fill(theme.hour);
      const mHand = hands.rect(0, 0).fill(theme.minute);

      const sHand = hands.group();
      const sMain = sHand.rect(0, 0).fill(theme.second);
      const sTail = sHand.rect(0, 0).fill(theme.second);

      const centerDot = draw.circle(0).center(0,0)
        .fill("#cfcfcf")
        .stroke({width:0, color:"rgba(0,0,0,.25)"});

      function apply(scale, cx, cy){
        hHand.size(cfg.hand.hourW * scale, cfg.hand.hourL * scale)
          .move(cx - (cfg.hand.hourW * scale)/2, cy - cfg.hand.hourL * scale)
          .radius(2 * scale);

        mHand.size(cfg.hand.minW * scale, cfg.hand.minL * scale)
          .move(cx - (cfg.hand.minW * scale)/2, cy - cfg.hand.minL * scale)
          .radius(2 * scale);

        sMain.size(cfg.hand.secW * scale, cfg.hand.secL * scale)
          .move(cx - (cfg.hand.secW * scale)/2, cy - (cfg.hand.secL - 10) * scale);

        sTail.size(cfg.hand.secTailW * scale, cfg.hand.secTailL * scale)
          .move(cx - (cfg.hand.secTailW * scale)/2, cy + cfg.hand.secTailOffsetY * scale);

        centerDot.size(cfg.centerDot * scale)
          .center(cx,cy)
          .stroke({width:1 * scale, color:"rgba(0,0,0,.25)"});
      }

      function rotate(hrDeg, minDeg, secDeg, cx, cy){
        hHand.untransform().rotate(hrDeg,  cx, cy);
        mHand.untransform().rotate(minDeg, cx, cy);
        sHand.untransform().rotate(secDeg,  cx, cy);
      }

      return { apply, rotate };
    }

    const hands = createHands(draw);

    let lastAngles = { hrDeg: 0, minDeg: 0 };

    function applyMetrics(){
      const { base, scale, cx, cy } = metrics;

      draw.viewbox(0,0,base,base);
      drawFrame();
      drawTicksAndNumbers();
      hands.apply(scale, cx, cy);
      applyDateLayout(scale);
    }

    function applyDateLayout(scale){
      dateMini.setScale(scale);
      dateMini.placeDateOutsideAngle(lastAngles.hrDeg, lastAngles.minDeg);
    }

    let resizeRaf = null;
    function onResize(){
      if(resizeRaf) return;
      resizeRaf = requestAnimationFrame(() => {
        resizeRaf = null;
        metrics = applyBase(computeBase());
        dateMini.rebuild();
        applyMetrics();
        dateMini.setAllNow(new Date());
      });
    }

    applyMetrics();
    window.addEventListener("resize", onResize);

    /* ===== tick ===== */
    function updateHandsForDate(d){
      const sec = d.getSeconds();
      const min = d.getMinutes() + sec/60;
      const hr  = (d.getHours()%12) + min/60;

      const hrDeg  = hr * 30;
      const minDeg = min * 6;
      const secDeg = sec * 6;

      lastAngles = { hrDeg, minDeg };
      hands.rotate(hrDeg, minDeg, secDeg, metrics.cx, metrics.cy);
    }

    function tickAlignedOncePerSecond(){
      const d = new Date();
      updateHandsForDate(d);
      applyDateLayout(metrics.scale);
      dateMini.updateDateIfNeeded(d);
      dateMini.updateTimeFields(d);

      setTimeout(tickAlignedOncePerSecond, 1000 - d.getMilliseconds());
    }

    tickAlignedOncePerSecond();
  </script>
</body>
</html>
